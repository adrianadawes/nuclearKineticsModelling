\documentclass{article}
\usepackage{amsmath}
\usepackage{hyperref}

\author{Matt McDermott}
\title{Documentation for \texttt{C++} model}
\begin{document}
\maketitle
\section{Parameter Values:}
\begin{description}
  \item[\texttt{Tau}$=\tau$:] $\tau$ measures the timestep for the model and is currently
    $\frac{1}{4000}$ minutes. 
  \item[\texttt{Contact Length}:] This measures the length of time that an MT
    attached to the Cortex remains attached. It is currently
    \texttt{400*Tau}$=\frac{1}{10}$ minutes. 
  \item[\texttt{Vg}$=V_g$:] This measures the growth velocity of an MT and is
    currently $40 \mu m/\text{min}$. 
  \item[\texttt{Vs}$=V_s$:] This measures the shrinking velocity of an MT and is
    currently $120 \mu m/\text{min}$. 
  \item[\texttt{Vs\_c}$={V_s}_c$:] This measures the shrinking velocity of an MT
    post contact and is currently $120 \mu m/\text{min}$. 
  \item[\texttt{kc}$=k_c$:] This measures the catastrophe frequency of an MT and
    is currently $.1\cdot 60 1/\text{min}$. 
  \item[\texttt{kr}$=k_r$:] This measures the catastrophe frequency of an MT and
    is currently $.4\cdot 60 1/\text{min}$. 
  \item[\texttt{R1\_max}$=R_1$:] This measures the maximum length of the
    ellipsoidal cell body along the $x$-axis and is currently $50\mu m$.  
  \item[\texttt{R2\_max}$=R_2$:] This measures the maximum length of the
    ellipsoidal cell body along the $y$-axis and is currently $30\mu m$.  
  \item[\texttt{Prad}$=P_{\text{rad}}$:] This measures the radius of the
    pronucleus and is currently $5\mu m$.  
  \item[\texttt{Eta}$=\eta$:] This measures the translational drag coefficient
    of the pronucleus and is currently $1\frac{\text{pN}}{\mu m \text{min}}$. 
  \item[\texttt{Mu}$=\mu$:] This measures the translational drag coefficient
    of the pronucleus and is currently $5\eta = 5\frac{\text{pN}}{\mu m \text{min}}$. 
\end{description}
\section{Usage Instructions:}
  The three basic steps to to use this code are:\\
  \textbf{To Compile:} Run \texttt{make} on the command line.\\
  \textbf{To Run:} After compilation, run
  \begin{verbatim}
  ./mtKineticModel <Number of Runs> <Output File> [temp/all]
  \end{verbatim}
  on the command line. Here, \texttt{<Number of Runs>} denotes the number of
  runs of the given system the model should produce and \texttt{<Output File>}
  specifies the file to which the results should be written. Note that this file
  will be placed in the directory \texttt{nuclearKineticsModelling/data}. The
  final paramterer, \texttt{[temp/all]}, is an optional parameter. If omitted,
  the system will only store the final configuration of the system in the result
  file. If given as \texttt{temp}, it will store 30 second time slices in the
  result system for each model run, in sequence (i.e. it will list various
  parameters for 30 second slices for the first run, then those for the second,
  and so on and so forth). If given as \texttt{all}, it will write data for
  every timestep in the result file, in sequence, for each model run. \\
  \textbf{To View: } There are a variety of matlab scripts in the
  \texttt{plottingCode} folder to visualize the results. Of particular note are
  the histogram scripts, \texttt{positionRotationHist.m} and
  \texttt{positionRotationHistCompare.m}, the single-run visualization tool,
  \texttt{readData.m}, and the movie-frame making scripts
  \texttt{movieMaker*.m}. All of these scripts are run with the following basic
  premise: Open \texttt{MATLAB}, set values \texttt{dataDir} and
  \texttt{dataFile} \textit{(and/or \texttt{dataFile2})} in the \texttt{MATLAB}
  console, then run the script. \texttt{dataDir} stands for the directory (as a
  sub-directory of \texttt{'nuclearKineticsModelling/data/}) and
  \texttt{dataFile} stands for the dataFile in question. 
  \subsection{Basic Usage:}
  For basic usage, the only additional step beyond simple compilation and
  running is parameter modification. Here is a short description of some of the
  parameters we change most frequently \textit{(All found in the
  \texttt{parameters.cpp} file)}.
  \begin{description}
    \item[\texttt{springsOn} ] This boolean value controls whether the centrosomes
      are connected to the pronucleus rigidly (and thus not allowed to translate
      relative to the pronucleus) or via springs (of spring constant given later
      in the file).
    \item[\texttt{translation} ] This boolean value controls whether the
      pronucleus is allowed to translate. If it is \texttt{true}, the system
      proceeds in full generality. If it is \texttt{false}, the pronucleus
      center is fixed in the cortex (though it is allowed to rotate). If the
      springs are on, the centrosomes are also allowed to translate (and thus
      provide force via the springs to the pronucleus). 
    \item[\texttt{kM/kD} ] These parameters control the relative spring
      constants for the springs connecting the mother (\texttt{M}) centrosome and
      daughter (\texttt{D}) centrosome to the pronucleus, respectively. If
      springs are off, then these parameters do nothing. We do not yet have good
      values for these constants. 
    \item[\texttt{startX} ] This parameter controls the starting $x$ coordinate
      of the pronucleus, with $0$ being the center of the cell. We typically
      test starting at $0$ and starting at $7.5 \mu\text{m}$. 
    \item[\texttt{startPsi} ] This parameter controls the starting angular
      position of the pronucleus, in radians, with $0$ being \emph{horizontal}.
      For on-angle runs, we use $\frac{\pi}{2}$. To test the effects of angular
      variations, we typically use $\frac{\pi}{2} + k\frac{\pi}{8}$, with $1 \le
      k \le 4$, though it might be sensible to test larger $k$ and finer
      gradations. 
    \item[\texttt{numRegions/regionAngles/regionProbabilities} ] These are the
      band parameters, and control the number of uniform probability regions,
      the angular endpoints of those regions, and the associated probabilities
      with those regions. 
  \end{description}
  \subsection{Advanced Usage:}
  There are a variety of other parameters one may wish to modify, all of which
  found in the \texttt{parameters.cpp} file. For these modifications, the same
  procedure is used: modify the parameter, re-compile, and run. 
\section{Current Algorithm}
\subsection{High Level Description}
The current algorithm is very straightforward. In particular, for each step in
time, stepping by a set parameter \texttt{tau} through \texttt{Duration}
minutes, the algorithm computes the net force and torque on the pronucleus and
then uses an eulerian approximation of the solution to the DE inspired by
friction dominated domain conditions to update the position and angle of
rotation of the body. The algorithm also maintains a list of endpoints of a set
number of MTs, updating these through growth, shortening, and respawning when
necessary. It also uses the same risk formulas for catastrophe and rescue as did
the previous matlab model. The only real differences are that several bugs are
corrected, force and torque are calculated upon every iteration directly, and
the implementation outputs final data to a file for another program to read in. 
\subsection{Implementation Details}
\begin{itemize}
  \item It is important to the current implementation that \texttt{mt\_numb} is
    a constant value, as otherwise fixed-size arrays could not be used to store
    all the codes data. 
  \item The \texttt{parameters.cpp} file defines not only fixed constants for
    the program, but also initializes global variables and sets up two very
    import \texttt{typedef}s. The first sets a new \texttt{float\_T} type, which
    is used so that precision of the model can be altered painlessly, and the
    second creates a \texttt{vec\_T} type, which is used so that arrays of
    \texttt{float\_T}s are easy to create. 
  \item The two \texttt{operator} functions at the top of \texttt{main.cpp} are
    merely to aid in file output. 
  \item The net force calc function is simple; It merely sums up the all the force
    directions for the MTs, then multiplies that sum by the force for any given
    MT. This will give the net force on that centrosome. 
  \item The net force function is just a wrapper around net force calc. 
  \item The \texttt{updatePNPos()} function is an extraction of the code to
    update the position of the pronucleus from the main loop. The
    actual mechanics of the function are very straightforward currently, and
    simply translate the components of the force into torque and motion
    inspiring forces, respectively. 
  \item \texttt{advanceMT} is simply an encapsulation of some messy code from
    the loop. It grows or shrinks MTs. 
  \item \texttt{respawnMT} creates a new MT. 
  \item The main loop appropriately orders these functions, updates contact
    statistics, growth statistics, and growth velocities. It also checks for
    rescue and catastrophe and writes the data to the file. 
  \item Note here that a major implementation detail between this algorithm and
    the matlab one is that as this algorithm computes the force on every
    iteration, not just on a new contact, the \texttt{MT\_touch} array must be
    active every second, which in particular means that it cannot be used to
    distinguish between shortening velocities as it is in the matlab model. So,
    instead, an additional array is maintained, \texttt{MT\_GrowthVel\_*}, where
    * is either M or D. This stores the current growth velocity of the given MT. 
\end{itemize}
\section{Future Work}
\begin{enumerate}
  \item Test Stability\\
  \item Write up results. 
\end{enumerate}
\end{document}
